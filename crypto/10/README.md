# 10 Crypto - Заколдованные письмена

## Описание

Во время изучения Запретной секции библиотеки Хогвартса, один из преподавателей нашел древний свиток, зашифрованный каким-то числовым заклинанием. Свиток разделен пунктирными линиями на части, словно каждая из частей шифровалась отдельно. Рядом со свитком лежат инструкции по созданию других свитков, подобных найденному. Сможешь ли ты разобраться в том, как расшифровать содержимое пергамента?

- Рекомендуемые утилиты: Python.
- Цель работы: анализ представленного криптографического алгоритма.
- Итог работы: получение доступа к флагу.
- Критерий оценки: предоставление правильного флага.

## Решение

### Подробное решение

Рассмотрим алгоритм шифрования:

1. Создаются два больших простых числа: `m` (модуль) и `k` (секретный ключ). `m` нам известен, а `k` нет.
2. Флаг разбивается на блоки по 4 символа.
3. Каждый блок преобразуется в большое целое число.
4. Каждое число-блок `P` шифруется по формуле `C = (P * k) % m`.
5. Мы получаем список зашифрованных чисел `cipher` и модуль `m`.

Главная уязвимость этого алгоритма в том, что для шифрования всех блоков используется один и тот же ключ `k`. Поскольку мы знаем формат флага `vsosh{...}`, мы можем с уверенностью сказать, что первый 4-символьный блок исходного текста - `'vsos'`.

Зная `P1` и соответствующий ему шифротекст `C1` (`cipher[0]`), мы можем восстановить секретный ключ `k`.

У нас есть уравнение:
`C1 = (P1 * k) % m`

Чтобы найти `k`, нам нужно разделить `C1` на `P1` по модулю `m`. В модульной арифметике деление эквивалентно умножению на обратное число.

Формула для нахождения `k` выглядит так:
`k = (C1 * pow(P1, -1, m)) % m`

Где `pow(P1, -1, m)` - это встроенная функция Python, которая вычисляет модульное обратное для `P1` по модулю `m`.

Теперь, когда у нас есть ключ `k`, мы можем расшифровать все остальные блоки. Для этого нам нужно найти обратный элемент к `k` (`pow(k, -1, m)`), который будет нашим ключом для расшифровки.

Для каждого зашифрованного блока `C` из списка `cipher` мы вычисляем исходный блок `P` по формуле:
`P = (C * pow(k, -1, m)) % m`

Каждый полученный блок `P` - это число. Мы преобразуем его обратно в 4-символьную строку. Соединив все строки вместе, мы получаем исходный флаг.

## Solver

```python
cipher = [42368310502504114813877130201039046007161162531350601855404198307400664672347098535647771606007548052849792507213626445832571184592934486879866153143119413774554328914208163395259745478540557796485289955230117222880713882774011984762455321644544270048295434206894632939172117076959620757622626168017912781305, 126843258541635275029728155193887875667924848566747200901034363237697527216380674026080675047224251678462759745273782531204055293587229563340990875334499604698248727476119700316547286856400546473235176745283096525884668769479038303630263389331482021283856617937805282161368272131854077479354124720128395517601, 166172928903152198962402443408557140229709938532972520714831490208132231961652977719848071792987657512726038673911300545672157162577812929846535952349256936482820633733790251264168802051333453905991040268520185092376599832745369118771134357640134322672820016782993050848575319927333828705851332902469550681919, 14516438503428207008537153901982692546395854645210661348864168695735223287778676096895979977022035644434500429312137939274839334725942119196435517004845627507274360127866982873011207326408739400559508887440120690706343343470426837471833789152213559514049840566805119042582986998661053503479216792500360437983, 164725896310010266720679290382971360646730678960623450828829539669982343348911977790479166458126329113353042978916777759680863087722487748808852572021856422243519476435989800549827565176329433714122096251592304755176723906019406210375192650084196655167026552160212440630037721594188752473257674051524694555359, 4563737869193132550457300497636553606602542152774082050349680082494471689711669997316413477814416965000606660404063380741238404542765270186492260406856968130298356017513751112814807691119325855974220415765989604745836003139464362178451079812397896227009962487847059848958747439250641827396314932853802608606, 128946633079969413099095639491512870329998618865176919559695063038861570116112926816166900682258091139047082154101920806940180272441709672276225552146072728983349503216081041188321586903331875383877151290966667383066329829064165845402941731417773833134711874599092111315147938158745969599342308625676704750962, 82774276532641703196520124658261550371696016104867953801431683403355396555803471015864264037750574597394282377586231614461312768775416705094273597325059348257099828879157965978263749365014758132826563670932507637414770609582321618113307145832326110769859733843103016028359568019153922512500492956751105810502]
m = 170733732163459673419023186687682239298904304480792630172549013712601875848530295344530938999278698053356381720360979134573344426540859197306195093887276945952227144077739839725208106979656223590949452322936615384798853364480767001342422696586875331563092353762883945585104950633253337727765994940005313306223

block1 = int(b'vsos'.hex(), 16)

k = cipher[0] * pow(block1, -1, m) % m

flag = ""
for c in cipher:
    decrypted_block = c * pow(k, -1, m) % m
    block_hex = hex(decrypted_block)[2:]
    flag += bytes.fromhex(block_hex).decode()

print(flag)
```
