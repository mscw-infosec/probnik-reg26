# 11 crypto - 

## Описание

На экзамене по нумерологии студентам "Хогвартса" выдали таблички, на которых были начерчены криптографические руны. Задача экзамена - найти уязвимость в
механизме работы рун и проэксплуатировать её.

- Рекомендуемые утилиты: Python.
- Цель работы: анализ представленного криптографического алгоритма.
- Итог работы: получение доступа к флагу.
- Критерий оценки: предоставление правильного флага.

## Решение

Задание основано на криптосистеме RSA. Безопасность RSA строится на том, что зная только открытый модуль n, практически невозможно разложить его на исходные простые множители p и q.

В этом задании нам даны стандартные параметры RSA (n, e, c), а также одно дополнительное число s. Изучив скрипт, мы видим, как оно вычисляется:
s = p % q

Здесь и кроется уязвимость. Взглянем на то, как генерируются p и q:

```python
p = getPrime(512)
q = getPrime(514)
```
Это означает, что `p` - это 512-битное число, а `q` - 514-битное. Следовательно, `p` гарантированно меньше `q` (`p < q`).

Вспомним свойство операции взятия остатка: если `a < b`, то `a % b = a`.
Поскольку `p < q`, то уравнение `s = p % q` упрощается до `s = p`.

Таким образом, нам просто напрямую отдали один из простых множителей `p`.

Теперь, когда мы знаем `p`, найти `q` становится тривиальной задачей. Так как `n = p * q`, то:
`q = n // p`

Зная оба простых множителя `p` и `q`, мы можем вычислить функцию Эйлера:
`phi = (p - 1) * (q - 1)`

Эта величина необходима для нахождения секретного ключа `d`. Секретный ключ `d` является обратным для `e` по модулю `phi`:
`d = pow(e, -1, phi)`

Имея полный набор ключей (`n`, `d`), мы можем расшифровать исходное сообщение из шифротекста `c` по стандартной формуле расшифровки RSA:
`m = pow(c, d, n)`

Полученное число `m` является числовым представлением флага. Остается только преобразовать его обратно в текст, чтобы получить флаг.

## Solver

```python
n = 218488722788049846237267888390617787058787746246157699971541152124185400512280038071863172777524074806183978437772258399321847925076825733925044881148550840848619534865621581958103701733505052002947299094825454944481811728906824086073771128270347997223086194302762083049430998016340188701597165474302549796573
e = 65537
d = 89226424412154448398526599705303789505796652891224265407911979423099898672668308573101392438128909442188504187078089076391197916699820924710772558998120355560871125521287272740352867355052632373495313643750633533886064956910719986033850068742953900918047177847900319399737608943108025415991864781602901494353
s = 7748223410810018501973780812957043943881861601612720599489901738735544052910340997055692291140066290412375107200921580365543469736143554622156091080373863
c = 190252022453763568199703249403579188237913133567909427114959919685398006632544660899271825350997351450680483555080553696130792121783468907369849341420099657700115264701313135852066218925849833505235292458456648143352990515277849207905070023232870507625675001735905524708298344320114730175120538036474694402475


p = s
q = n // p

d = pow(e, -1, (p - 1) * (q - 1))

print(bytes.fromhex(hex(pow(c, d, n))[2:]).decode())
```
