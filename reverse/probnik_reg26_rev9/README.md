# Что-то знал
Человек всегда что-то знает. А если не знает, то должен знать.

## Сборка
Под 32бита и с O2 получается нормальное количество мусора в декомпиляции гидры.
```
gcc -m32 -O2 chall.c -o chall_32
```

## Решение

Открываем бинарь в Ghidra, приводим немного в порядок код (переименовываем переменные, меняем типы (не забывая про размеры типов)). Получаем примерно следующее:

```c
undefined4 main(void)
{
  int iVar1;
  undefined1 prikol1;
  int i;
  int in_GS_OFFSET;
  undefined8 uVar2;
  undefined4 uStack_154;
  undefined4 uStack_150;
  undefined1 auStack_14c [8];
  char out [32];
  char input [128];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __isoc99_scanf(&DAT_00012008,input);
  prikol1 = prikol(input);
  i = 0;
  do {
    *(uint *)(out + i) =
         *(uint *)(input + i) ^ CONCAT13(prikol1,CONCAT12(prikol1,CONCAT11(prikol1,prikol1)));
    i = i + 4;
  } while (i != 32);
  i = memcmp(out,FLAG,0x20);
  if (i == 0) {
    puts("ok");
  }
  else {
    puts("not ok");
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return 0;
  }
  uStack_154 = 0x1116e;
  uVar2 = __stack_chk_fail_local();
  uStack_154 = (undefined4)uVar2;
  __libc_start_main(main,uStack_150,auStack_14c,0,0,(int)((ulonglong)uVar2 >> 0x20),&uStack_154);
  do {
                    /* WARNING: Do nothing block with infinite loop */
  } while( true );
}
```

Тут уже можно заметить, что введенная строка передаётся в функцию `prikol`, которая возвращает один байт; а потом просто все введённые символы ксорятся с некоторым странным выражением с `CONCAT*` и полученные байты записываются в другой буфер. Затем этот буфер проверяется на равенство с константой через `memcmp`.

Последние несколько строк - это какая-то галлюцинация Ghidra. На самом деле это декомпиляция функции `_start`, и не имеет к `main` особого отношения.

Давайте разберемся, что значит длинное выражение с несколькими `CONCAT`. Если посмотреть в ассемблер, там будет несколько странных операций над переменными, при этом там не происходит никаких сложных преобразований и можно предположить, что это просто особенности кода, который генерирует компилятор, и на самом деле там просто происходит `out[i] = input[i] ^ prikol1`.

Далее, давайте посмотрим на `prikol()`. Опять поменяем названия на более удобные и заменим тип аргумента с `int` на `char*`, и получится примерно следующее:
```c
int prikol(char *param_1)
{
  int out;
  int i;
  int j;
  
  out = 0;
  for (i = 0; i < 3; i = i + 1) {
    for (j = 0; j < 6; j = j + 3) {
      out = param_1[j] * i * (out + param_1[i] * j);
    }
  }
  return out;
}
```

Заметим, что `out` зависит только от первых 6 символов аргумента. При этом мы знаем эти 6 символов, т.к. знаем префикс флага (`vsosh{`). Поэтому расчитать `prikol1` можно легко, просто переписав этот код на Python. Получится число 6.

Далее просто копируем константу `FLAG` из Ghidra в скрипт и ксорим. Получаем флаг.
