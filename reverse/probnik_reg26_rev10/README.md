# Я ходил в школу!
Я узнал столько всего за 8 класс в школе, что придумал задачку...

## Решение

Открываем бинарь в Ghidra, переименовываем переменные для удобства, получаем примерно следующее:
```c
undefined8 main(void)
{
  char idx;
  undefined2 ec_val;
  int iVar1;
  long in_FS_OFFSET;
  int i;
  undefined2 out [32];
  char input [264];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  puts("enter the flag ");
  __isoc99_scanf(&DAT_00102014,input);
  memset(out,0,64);
  for (i = 0; i < 0x20; i = i + 1) {
    idx = find(ALPHABET,(int)input[i]);
    ec_val = ec((int)idx);
    out[i] = ec_val;
  }
  iVar1 = memcmp(out,FLAG,0x40);
  if (iVar1 == 0) {
    puts("correct!");
  }
  else {
    puts("incorrect");
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```

Отсюда можно понять, что программа на каждый из 32 введенных символов находит индекс символа в алфавите, этот индекс передает в функцию `ec` и записывает в массив `out`. Далее этот массив сравнивается с константой через `memcmp`.

Тут стоит заметить очень важный момент: проверяются только 32 символа ввода (32 байта), но при этом `memset` и `memcmp` над `out` делаются для 64 байт. Отсюда можно понять, что функция `ec` возвращает число размером 2 байта. Ещё один связанный с этим момент - на x86 числа хранятся в little-endian, т.е. старшие байты находятся в памяти позже младших байтов. Уверен, что многие не решили эту задачу как раз по этой причине :)

Для того, чтобы "соединить" два байта из массива `FLAG` в одно число в Python, достаточно следующих битовых операций:
```python
FLAG = [a | b << 8 for a, b in itertools.batched(FLAG_ORIG, 2)]
```

Теперь давайте разберемся с функцией `ec`. Она просто подставляет значение символа в многочлен второй степени:
```c
int ec(char inp)
{
  int x;
  
  x = (int)inp;
  return x * 0x25 + x * x * 3 + 42;
}
```

Для того, чтобы узнать исходный символ `x`, зная значение `ec(x)` (а у нас есть эта информация из константы `FLAG`), нужно просто посчитать корень квадратного уравнения (отсюда и название таска).

Итоговое решение в файле [splo.py](splo.py)
